# ArrayBag.java
This project is about implementing a bag data structure with the use of an array. It utilizes methods within the array bag class that allows for the manipulation and retreival of the data inside. 

Section 1: Project Specification and Implementation
	The data type I chose for this project was a bag. A bag is an abstract data type (ADT), which is a specification of a data set and the operations on that data. However, the specification does not indicate how the data set is stored or how to implement those operations. This specification is independent of any programming language. The ADT bag is a finite collection of objects that are stored in no particular order, and this bag can contain duplicates of objects already in the bag. The bag implements an array, which is a linear data structure. I chose to use an array since we are storing string objects that can be added and removed through the use of index numbers, which indicate the slot in the array an object is being referenced. Using an array also allows for the duplicates of an object to be added to the bag. Moreover, since I used an array bag, I got the benefits of speed when it comes to adding entries and removing unspecified entries to the bag. This makes using an array bag ideal for this project since I am adding many entries from the file javakeywords.txt. To construct a bag requires to describe its data and specify in detail the methods that the bag will implement. For example, I described two private variables, “numberOfEntries” that stores the number of entries in the bag and “MAX_CAPACITY” which served as the limit for how many entries the “bag” could have, and a private generic array that acts as the “bag.” There were nine public interfaces in the “BagInterface”  interface used for the array bag and two private methods that assist with the public interfaces. Starting with the private methods, the first method was the “isArrayFull'' method which would compare if the “numberOfEntries” was greater than or equal to the “MAX_CAPACITY” and return true if it was and false if it was not. The second private method was “getIndexOf” which would return the index of a given object. It used a boolean variable “found,” defaulted at false, and two integer variables “index,” defaulted at -1, and “count,” defaulted at 0. The while loop would increase “count” by one each time it cycled, and would continue if “found” was false and “count” was less than the number of entries. If the object was found, it set “found” to true and returned the value for “index” after the while loop closed. Moving on to the public interface, the two “remove” interfaces were coded to remove an unspecified entry or a specified entry within the bag if the parameter of an entry was passed through the remove interface, all while decreasing the number of entries by one if it was successful in removing the entry. The first “remove” interface would remove an unspecified entry from the bag, returning either the object removed or null if it successfully removed an object from the bag. The second “remove” interface would get the index of the specified entry, set it to the last index available, and set it to null, erasing the specified entry from the bag. The “add” interface would add an entry to the bag, which would require a parameter to be passed to the interface. If the entry was successfully added, the interface would return true. However, it had to pass an if-statement in order to add the entry to the bag. The if-statement would make the interface return false, not adding anything, if “isArrayFull” was true, meaning there was no more space in the bag for entries. If returned false, the system would output “Bag is full, can not add more objects” notifying the user that the max capacity of the bag has been met.  Next, the “contains” interface would iterate through the bag searching for the parameter given to it, and return true if the entry existed in the bag or return false if it could not find the entry. The interface “getFrequencyOf” would receive an entry and iterate through the bag, increasing a counter by one each time it encountered an object that matched the entry given to it. It would return the counter to the main program in the form of an integer. In addition, the interface “getCurrentSize” would return “numberOfEntries” in the bag. Moving forward, the “isEmpty” interface would return true if the “numberOfEntries” was less than or equal to zero, or else it would return false. Also, the interface “clear” would remove all entries from the bag, making “numberOfEntries” equal to zero. The interface used a while loop that would keep removing unspecified objects while the condition “!isEmpty” kept returning true. Finally, the interface “toArray” would create a generic array, having enough entries that were equal to the variable “numberOfEntries.” Then, it would use a for loop that would set the generic array’s index at the number of cycles the for loop has gone through equal to the value at the bag’s index that matched the generic array’s index number. Using an array bag allowed for the fast addition and subtraction of objects from the bag, and took longer for searches of specific entries and translating the bag to an array. By incorporating these interfaces, the program functioned as it was intended all while saving creating objects efficiently.
