# ArrayBag.java
This project is about implementing a bag data structure with the use of an array. It utilizes methods within the array bag class that allows for the manipulation and retreival of the data inside. 

Section 1: Project Specification and Implementation
	The data type I chose for this project was a bag. A bag is an abstract data type (ADT), which is a specification of a data set and the operations on that data. However, the specification does not indicate how the data set is stored or how to implement those operations. This specification is independent of any programming language. The ADT bag is a finite collection of objects that are stored in no particular order, and this bag can contain duplicates of objects already in the bag. The bag implements an array, which is a linear data structure. I chose to use an array since we are storing string objects that can be added and removed through the use of index numbers, which indicate the slot in the array an object is being referenced. Using an array also allows for the duplicates of an object to be added to the bag. Moreover, since I used an array bag, I got the benefits of speed when it comes to adding entries and removing unspecified entries to the bag. This makes using an array bag ideal for this project since I am adding many entries from the file javakeywords.txt. To construct a bag requires to describe its data and specify in detail the methods that the bag will implement. For example, I described two private variables, “numberOfEntries” that stores the number of entries in the bag and “MAX_CAPACITY” which served as the limit for how many entries the “bag” could have, and a private generic array that acts as the “bag.” There were nine public interfaces in the “BagInterface”  interface used for the array bag and two private methods that assist with the public interfaces. Starting with the private methods, the first method was the “isArrayFull'' method which would compare if the “numberOfEntries” was greater than or equal to the “MAX_CAPACITY” and return true if it was and false if it was not. The second private method was “getIndexOf” which would return the index of a given object. It used a boolean variable “found,” defaulted at false, and two integer variables “index,” defaulted at -1, and “count,” defaulted at 0. The while loop would increase “count” by one each time it cycled, and would continue if “found” was false and “count” was less than the number of entries. If the object was found, it set “found” to true and returned the value for “index” after the while loop closed. Moving on to the public interface, the two “remove” interfaces were coded to remove an unspecified entry or a specified entry within the bag if the parameter of an entry was passed through the remove interface, all while decreasing the number of entries by one if it was successful in removing the entry. The first “remove” interface would remove an unspecified entry from the bag, returning either the object removed or null if it successfully removed an object from the bag. The second “remove” interface would get the index of the specified entry, set it to the last index available, and set it to null, erasing the specified entry from the bag. The “add” interface would add an entry to the bag, which would require a parameter to be passed to the interface. If the entry was successfully added, the interface would return true. However, it had to pass an if-statement in order to add the entry to the bag. The if-statement would make the interface return false, not adding anything, if “isArrayFull” was true, meaning there was no more space in the bag for entries. If returned false, the system would output “Bag is full, can not add more objects” notifying the user that the max capacity of the bag has been met.  Next, the “contains” interface would iterate through the bag searching for the parameter given to it, and return true if the entry existed in the bag or return false if it could not find the entry. The interface “getFrequencyOf” would receive an entry and iterate through the bag, increasing a counter by one each time it encountered an object that matched the entry given to it. It would return the counter to the main program in the form of an integer. In addition, the interface “getCurrentSize” would return “numberOfEntries” in the bag. Moving forward, the “isEmpty” interface would return true if the “numberOfEntries” was less than or equal to zero, or else it would return false. Also, the interface “clear” would remove all entries from the bag, making “numberOfEntries” equal to zero. The interface used a while loop that would keep removing unspecified objects while the condition “!isEmpty” kept returning true. Finally, the interface “toArray” would create a generic array, having enough entries that were equal to the variable “numberOfEntries.” Then, it would use a for loop that would set the generic array’s index at the number of cycles the for loop has gone through equal to the value at the bag’s index that matched the generic array’s index number. Using an array bag allowed for the fast addition and subtraction of objects from the bag, and took longer for searches of specific entries and translating the bag to an array. By incorporating these interfaces, the program functioned as it was intended all while saving creating objects efficiently.

Section 2: Testing Methodology
	The tests for each interface were different depending on the interfaces and factors being used when testing them. Using javakeywords.txt, I tested “add” by adding the strings from the text file into the bag, and I tested “getCurrentSize'' to return the number of java keywords loaded into the bag. In addition, I used “contains” to check if the command line arguments were “contained” within the bag, confirming whether or not they existed within the bag. I also tested “contains” outside of the tests that utilized the text file. This test consisted of checking the bag if it “contained” the word “joshua” inside the bag. It would return false, so I added “joshua” to the bag and ran the “contain” method again, which returned true. This proved that the contain method worked when checking for specific entries. Then, I tested the “getFrequencyOf” method by checking how many “continue” objects were in the bag. After returning the value, I added three more “continue” into the bag and ran “getFrequencyOf” again, always returning the original value plus three more each time. Next, I tested “remove” of a specific entry by adding the object “if” into the bag. I would check the frequency of “if,” then use the remove interface to remove “if” from the bag to see if the frequency would work correctly. I ran “getFrequencyOf” on the object “if” and the tests would always result in one less “if” in the bag than the original value. Moving forward, I tested the “remove” of a random entry and “getCurrentSize” together. I would check the current size of the bag first, then call the “remove” of a random entry. After, I called the “getCurrentSize” interface, always showing that the current size would decrease by one for the tests. Next, I tested the “isEmpty” and “clear” interfaces together. I would call “isEmpty” and see it return false. So, I called “clear” and emptied the bag, then called “isEmpty” which would return true for every test. Finally, I tested the “toArray” interface by calling the interface to the bag. Then, I printed out every object in the newly made array. Using javakeywords.txt and testing interfaces and methods that were not used directly in the comparison of keywords, the code shows that it functions properly as an array bag.
